# Конструкция try..catch..finally

## Полезные ссылки

[Обработка исключений](https://metanit.com/sharp/tutorial/2.14.php)
[Типы исключений. Класс Exception](https://metanit.com/sharp/tutorial/2.29.php)
[Обработка ошибок в асинхронных методах](https://metanit.com/sharp/tutorial/13.4.php)

Иногда при выполнении программы возникают ошибки, которые трудно предусмотреть или предвидеть, а иногда и вовсе невозможно. Например, при передачи файла по сети может неожиданно оборваться сетевое подключение. такие ситуации называются исключениями. Язык C# предоставляет разработчикам возможности для обработки таких ситуаций. Для этого в C# предназначена конструкция **try...catch...finally**.
```csharp  
try
{
     
}
catch
{
     
}
finally
{
     
}
```
При использовании блока **try...catch..finally** вначале выполняются все инструкции в блоке **try**. Если в этом блоке не возникло исключений, то после его выполнения начинает выполняться блок **finally**. И затем конструкция **try..catch..finally** завершает свою работу.

Если же в блоке **try** вдруг возникает исключение, то обычный порядок выполнения останавливается, и среда CLR начинает искать блок catch, который может обработать данное исключение. Если нужный блок catch найден, то он выполняется, и после его завершения выполняется блок **finally**.

Если нужный блок **catch** не найден, то при возникновении исключения программа аварийно завершает свое выполнение.

```csharp  
  try
        {
            int x = 5;
            int y = x / 0;
            Console.WriteLine($"Результат: {y}");
        }
        catch
        {
            Console.WriteLine("Возникло исключение!");
        }
        finally
        {
            Console.WriteLine("Блок finally");
        }
        Console.WriteLine("Конец программы");
        Console.Read();
    }
```

Следует отметить, что в этой конструкции обязателен блок try. При наличии блока catch мы можем опустить блок finally:
```csharp  
try
{
    int x = 5;
    int y = x / 0;
    Console.WriteLine($"Результат: {y}");
}
catch
{
    Console.WriteLine("Возникло исключение!");
}
```
И, наоборот, при наличии блока finally мы можем опустить блок catch и не обрабатывать исключение:
```csharp  
try
{
    int x = 5;
    int y = x / 0;
    Console.WriteLine($"Результат: {y}");
}
finally
{
    Console.WriteLine("Блок finally");
}
```
Однако, хотя с точки зрения синтаксиса C# такая конструкция вполне корректна, тем не менее, поскольку CLR не сможет найти нужный блок catch, то исключение не будет обработано, и программа аварийно завершится.
## Типы исключений
Базовым для всех типов исключений является тип Exception. Этот тип определяет ряд свойств, с помощью которых можно получить информацию об исключении.

- **InnerException**: хранит информацию об исключении, которое послужило причиной текущего исключения

- **Message**: хранит сообщение об исключении, текст ошибки

- **Source**: хранит имя объекта или сборки, которое вызвало исключение

- **StackTrace**: возвращает строковое представление стека вызывов, которые привели к возникновению исключения

- **TargetSite**: возвращает метод, в котором и было вызвано исключение

Например, обработаем исключения типа Exception:
```csharp  
static void Main(string[] args)
{
    try
    {
        int x = 5;
        int y = x / 0;
        Console.WriteLine($"Результат: {y}");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Исключение: {ex.Message}");
        Console.WriteLine($"Метод: {ex.TargetSite}");
        Console.WriteLine($"Трассировка стека: {ex.StackTrace}");
    }
 
    Console.Read();
}
```
  ![Обработка ошибок в асинхронных методах](https://metanit.com/sharp/tutorial/pics/2.11.png)
  Однако так как тип Exception является базовым типом для всех исключений, то выражение catch (Exception ex) будет обрабатывать все исключения, которые могут возникнуть.

Но также есть более специализированные типы исключений, которые предназначены для обработки каких-то определенных видов исключений. Их довольно много, я приведу лишь некоторые:
- **DivideByZeroException**: представляет исключение, которое генерируется при делении на ноль

- **ArgumentOutOfRangeException**: генерируется, если значение аргумента находится вне диапазона допустимых значений

- **ArgumentException**: генерируется, если в метод для параметра передается некорректное значение

- **IndexOutOfRangeException**: генерируется, если индекс элемента массива или коллекции находится вне диапазона допустимых значений

- **InvalidCastException**: генерируется при попытке произвести недопустимые преобразования типов

- **NullReferenceException**: генерируется при попытке обращения к объекту, который равен null (то есть по сути неопределен)

И при необходимости мы можем разграничить обработку различных типов исключений, включив дополнительные блоки catch:
```csharp  
static void Main(string[] args)
{
    try
    {
        int[] numbers = new int[4];
        numbers[7] = 9;     // IndexOutOfRangeException
 
        int x = 5;
        int y = x / 0;  // DivideByZeroException
        Console.WriteLine($"Результат: {y}");
    }
    catch (DivideByZeroException)
    {
        Console.WriteLine("Возникло исключение DivideByZeroException");
    }
    catch (IndexOutOfRangeException ex)
    {
        Console.WriteLine(ex.Message);
    }
             
    Console.Read();
}
```
