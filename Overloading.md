# Overloading

## Полезные ссылки

[Перегрузка методов](https://metanit.com/sharp/tutorial/3.5.php)

[Перегрузка операций преобразования типов](https://metanit.com/sharp/tutorial/3.37.php)

[Перегрузка операторов](https://metanit.com/sharp/tutorial/3.36.php)


## Перегрузка методов


Иногда возникает необходимость создать один и тот же метод, но с разным набором параметров. 
И в зависимости от имеющихся параметров применять определенную версию метода. 
Такая возможность еще называется перегрузкой методов.

В языке C# мы можем создавать в классе несколько методов с одним и тем же именем, но разной сигнатурой. Что такое сигнатура? Сигнатура складывается из следующих аспектов:

* **Имя метода**

* **Количество параметров.** Пример:
```csharp  
  int Sum(int x, int y)
  {
      return x + y;
  }
  void Sum(int x, int y, int z)
  {
      Console.WriteLine(x + y+z);
  }
  ```
* **Типы параметров.** Пример:
```csharp  
  int Sum(int x, int y)
  {
      return x + y;
  }
  void Sum(int x, double y)
  {
      Console.WriteLine(x + y);
  }
  ```

*  **Порядок параметров**
```csharp 
  int Sum(int x, double y)
  {
      return x + y;
  }
  void Sum(double y, int x)
  {
      Console.WriteLine(x + y);
  }
  ```

* **Модификаторы параметров**
```csharp
  void Increment(ref int val)
  {
    val++;
    Console.WriteLine(val);
  }

  void Increment(int val)
  {
    val++;
    Console.WriteLine(val);
  }
```
Но названия параметров в сигнатуру **НЕ входят**. Например, возьмем следующий метод, КОТОРЫЙ СОДЕРЖИТ ОШИБКУ:


```csharp  
  int Sum(int x1, int y1)
  {
      return x + y;
  }
  void Sum(int x2, int y2)
  {
      Console.WriteLine(x + y);
  }
  ```
Отличие методов по возвращаемому типу или по имени параметров **не является** основанием для перегрузки. Например, возьмем следующий набор методов:
```csharp  
  int Sum(int x, int y)
  {
      return x + y;
  }
  int Sum(int number1, int number2)
  {
      return x + y;
  }
  void Sum(int x, int y)
  {
      Console.WriteLine(x + y);
  }
  ```
  
  Сигнатура у всех этих методов будет совпадать:
  
  ```csharp  
  Sum(int, int)
  ```
## Перегрузка операторов
Наряду с методами мы можем также перегружать операторы. Например, пусть у нас есть следующий класс Counter:
```csharp  
  class Counter
  {
      public int Value { get; set; }
  }
  ```
Данный класс представляет некоторый счетчик, значение которого хранится в свойстве Value.

И допустим, у нас есть два объекта класса Counter - два счетчика, которые мы хотим сравнивать или складывать на основании их свойства Value, используя стандартные операции сравнения и сложения:
```csharp  
Counter c1 = new Counter { Value = 23 };
Counter c2 = new Counter { Value = 45 };
 
bool result = c1 > c2;
Counter c3 = c1 + c2;
  ```
**Перегрузка операторов заключается в определении в классе, для объектов которого мы хотим определить оператор, специального метода:**
```csharp  
public static возвращаемый_тип operator оператор(параметры)
{ ... }
  ```
Этот метод должен иметь модификаторы public static, так как перегружаемый оператор будет использоваться для всех объектов данного класса. Далее идет название возвращаемого типа. Возвращаемый тип представляет тот тип, объекты которого мы хотим получить. К примеру, в результате сложения двух объектов Counter мы ожидаем получить новый объект Counter. А в результате сравнения двух мы хотим получить объект типа bool, который указывает истинно ли условное выражение или ложно. Но в зависимости от задачи возвращаемые типы могут быть любыми.

Затем вместо названия метода идет ключевое слово operator и собственно сам оператор. И далее в скобках перечисляются параметры. Бинарные операторы принимают два параметра, унарные - один параметр. И в любом случае один из параметров должен представлять тот тип - класс или структуру, в котором определяется оператор.

Например, перегрузим ряд операторов для класса Counter:
```csharp  
class Counter
{
    public int Value { get; set; }
         
    public static Counter operator +(Counter c1, Counter c2)
    {
        return new Counter { Value = c1.Value + c2.Value };
    }
    public static bool operator >(Counter c1, Counter c2)
    {
        return c1.Value > c2.Value;
    }
    public static bool operator <(Counter c1, Counter c2)
    {
        return c1.Value < c2.Value;
    }
}
  ```
Еще пример:
```csharp  
public static int operator +(Counter c1, int val)
{
    return c1.Value + val;
}
  ```
Пример вызова:
```csharp  
Counter c1 = new Counter { Value = 23 };
int d = c1 + 27; // 50
Console.WriteLine(d);
  ```
 Следует учитывать, что при перегрузке **не должны изменяться** те объекты, которые передаются в оператор через параметры. Например, мы можем определить для класса Counter оператор инкремента:
```csharp  
public static Counter operator ++(Counter c1)
{
    c1.Value += 10;
    return c1;
}
  ```
Поскольку оператор унарный, он принимает только один параметр - объект того класса, в котором данный оператор определен. Но это **неправильное определение** инкремента, так как оператор не должен менять значения своих параметров.

И более корректная перегрузка оператора инкремента будет выглядеть так:
```csharp  
public static Counter operator ++(Counter c1)
{
    return new Counter { Value = c1.Value + 10 };
}
  ```
  При перегрузке операторов надо учитывать, что **не все операторы можно перегрузить**. В частности, мы можем перегрузить следующие операторы:

- унарные операторы +, -, !, ~, ++, --

- бинарные операторы +, -, *, /, %

- операции сравнения ==, !=, <, >, <=, >=

- логические операторы &&, ||, true, false

- операторы присваивания +=, -=, *=, /=, %=

И есть ряд операторов, которые нельзя перегрузить, например, операцию равенства = или тернарный оператор ?:, а также ряд других.
Полный список перегружаемых операторов можно найти в [документации msdn](http://msdn.microsoft.com/ru-ru/library/8edha89s.aspx)

## Перегрузка операций преобразования типов
C помощью перегрузки операторов мы можем определять логику преобразования одних типов в другие. Для этого в классе определяется метод следующей формы:
```csharp  
public static implicit|explicit operator Тип_в_который_надо_преобразовать(исходный_тип param)
{
    // логика преобразования
}
  ```
  
  После модификаторов public static идет ключевое слово **explicit** (если преобразование явное, то есть нужна операция приведения типов) или **implicit** (если преобразование неявное). Затем идет ключевое слово **operator** и далее **возвращаемый тип**, в который надо преобразовать объект. В скобках в качестве параметра передается объект, который надо преобразовать.

Например, пусть у нас есть следующий класс Counter, который представляет счетчик-секундомер и который хранит количество секунд в свойстве Seconds:
```csharp  
class Counter
{
    public int Seconds { get; set; }
 
    public static implicit operator Counter(int x)
    {
        return new Counter { Seconds = x };
    }
    public static explicit operator int(Counter counter)
    {
        return counter.Seconds;
    }
}
  ```
  Первый оператор преобразует число - объект типа int к типу Counter. Его логика проста - создается новый объект Counter, у которого устанавливается свойство Seconds.

Второй оператор преобразует объект Counter к типу int, то есть получает из Counter число.
Примение операторов преобразования в программе:
```csharp  
static void Main(string[] args)
{
    Counter counter1 = new Counter { Seconds = 23 };
 
    int x = (int)counter1;
    Console.WriteLine(x);   // 23
             
    Counter counter2 = x;
    Console.WriteLine(counter2.Seconds);  // 23
}
  ```
###
